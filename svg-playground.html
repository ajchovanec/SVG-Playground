<head>
  <script>
    const percentToPixelsFactor = 7;

    const outerCircleRadius = 49;
    const innerStarCircleRadius = 14.75;
    const outerStarPointTipDistance = 50;
    const outerStarPointStraightDistance = 40;
    const logoCenterX = 50;
    const logoCenterY = 50;

    const alphaStarParam = 0.2675;
    const betaStarParam = 0.06;
    const gammaStarParam = 7.85;

    const darkPyramidFaceBottomFrontLeftToTopDeltaX = 6.8;
    const darkPyramidFaceBottomFrontLeftToBottomBackLeftDeltaX = 4.9;
    const darkPyramidFaceBottomFrontLeftToBottomBackLeftDeltaY = 3.6;

    const darkPyramidFaceToDarkPlatformFaceDeltaY = 3.96;

    const brightPlatformFaceBottomLeftToRightDeltaX = 49;
  </script>
  <style type="text/css">
    .parent {
      position: relative;
      top: 0;
      left: 0;
      height: 700px;
      width: 700px;
    }
    .layer {
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
      width: 100%;
      object-fit: contain;
    }
    .background {
      z-index: 1;
      background-color: green;
      opacity: 1;
    }
    .template {
      z-index: 2;
      opacity: 0;
    }
    .drawing {
      z-index: 3;
      opacity: 1;
    }
  </style>
</head>
<body>
  <div class="parent">
    <div class="background layer" />
    <img class="template layer" src="svg-template.png" />

    <svg class="drawing layer">
      <!-- Outer circle of logo.

           TODO: Figure out how to remove this without causing a visible
           boundary between the circle and the bottom of the platform. -->
      <circle
          cx="50%" cy="50%" r="49%" stroke-width="2%"
          stroke="white" fill="transparent"
          mask="url(#drawingMask)" />

      <!-- SVG content is added programmatically below. -->
    </svg>
    <script>
      let drawing = document.getElementsByClassName('drawing')[0];

      let drawingMask =
          document.createElementNS("http://www.w3.org/2000/svg", 'mask');
      drawingMask.setAttribute('id', 'drawingMask');
      drawing.append(drawingMask);

      let canvasRect =
          document.createElementNS("http://www.w3.org/2000/svg", 'rect');
      canvasRect.setAttribute('x', '0');
      canvasRect.setAttribute('y', '0');
      canvasRect.setAttribute('height', '100%');
      canvasRect.setAttribute('width', '100%');
      canvasRect.setAttribute('fill', 'white');
      canvasRect.setAttribute('mask', 'url(#drawingMask)');
      drawing.append(canvasRect);

      // Draw outer logo circle.
      drawCircle(
          logoCenterX,
          logoCenterY,
          outerCircleRadius,
          /* stroke= */ 'white',
          /* strokeWidth= */ '2%',
          /* fill= */ 'transparent');

      // Draw inner star circle.
      drawCircle(
          logoCenterX,
          logoCenterY,
          innerStarCircleRadius,
          /* stroke= */ 'white',
          /* strokeWidth= */ 1,
          /* fill= */ 'white');

      let pyramidFrontLeftEdgeSlope;
      let pyramidBackLeftEdgeSlope;
      let darkPyramidFaceTopX;
      let darkPyramidFaceTopY;

      for (let i = 0; i < 12; ++i) {
        let firstInnerPointAngle =
            alphaStarParam * Math.PI - i * Math.PI / gammaStarParam;
        let firstInnerX =
            innerStarCircleRadius * Math.cos(firstInnerPointAngle)
                + logoCenterX;
        let firstInnerY =
            innerStarCircleRadius * Math.sin(firstInnerPointAngle)
                + logoCenterY;

        let firstOuterPointAngle =
            alphaStarParam * Math.PI
                - (1 - betaStarParam) * Math.PI / (2 * gammaStarParam)
                - i * Math.PI / gammaStarParam;
        let firstOuterX =
            outerStarPointStraightDistance * Math.cos(firstOuterPointAngle)
                + logoCenterX;
        let firstOuterY =
            outerStarPointStraightDistance * Math.sin(firstOuterPointAngle)
                + logoCenterY;

        let secondOuterPointAngle =
            alphaStarParam * Math.PI
                - 1 * Math.PI / (2 * gammaStarParam)
                - i * Math.PI / gammaStarParam;
        let secondOuterX =
            outerStarPointTipDistance * Math.cos(secondOuterPointAngle)
                + logoCenterX;
        let secondOuterY =
            outerStarPointTipDistance * Math.sin(secondOuterPointAngle)
                + logoCenterY;

        let thirdOuterPointAngle =
            alphaStarParam * Math.PI
                - (1 + betaStarParam) * Math.PI / (2 * gammaStarParam)
                - i * Math.PI / gammaStarParam;
        let thirdOuterX =
            outerStarPointStraightDistance * Math.cos(thirdOuterPointAngle)
                + logoCenterX;
        let thirdOuterY =
            outerStarPointStraightDistance * Math.sin(thirdOuterPointAngle)
                + logoCenterY;

        let secondInnerPointAngle =
            alphaStarParam * Math.PI - 2 * Math.PI / (2 * gammaStarParam)
                - i * Math.PI / gammaStarParam;
        let secondInnerX =
            innerStarCircleRadius * Math.cos(secondInnerPointAngle)
                + logoCenterX;
        let secondInnerY =
            innerStarCircleRadius * Math.sin(secondInnerPointAngle)
                + logoCenterY;

        let starPoint =
            document.createElementNS("http://www.w3.org/2000/svg", 'path');
        starPoint.setAttribute(
          'd',
          `M ${firstInnerX * percentToPixelsFactor}
             ${firstInnerY * percentToPixelsFactor}
           L ${firstOuterX * percentToPixelsFactor}
             ${firstOuterY * percentToPixelsFactor}
           S ${secondOuterX * percentToPixelsFactor}
             ${secondOuterY * percentToPixelsFactor}
             ${thirdOuterX * percentToPixelsFactor}
             ${thirdOuterY * percentToPixelsFactor}
           L ${secondInnerX * percentToPixelsFactor}
             ${secondInnerY * percentToPixelsFactor}
           L ${firstInnerX * percentToPixelsFactor}
             ${firstInnerY * percentToPixelsFactor}`);
        starPoint.setAttribute('stroke', 'white');
        starPoint.setAttribute('fill', 'white');
        drawingMask.append(starPoint);

        if (i === 5) {
          pyramidFrontLeftEdgeSlope =
              (thirdOuterY - secondInnerY) / (thirdOuterX - secondInnerX);

          darkPyramidFaceTopX = secondInnerX - 1;
          darkPyramidFaceTopY =
              secondInnerY - 1 * pyramidFrontLeftEdgeSlope;
          console.log(
              'slope: ' + pyramidFrontLeftEdgeSlope + ', X: '
                  + darkPyramidFaceTopX + ', Y: ' + darkPyramidFaceTopY);
        }
      }

      let darkPyramidFaceBottomFrontLeftX =
          darkPyramidFaceTopX - darkPyramidFaceBottomFrontLeftToTopDeltaX;
      let darkPyramidFaceBottomFrontLeftY =
          darkPyramidFaceTopY
              - darkPyramidFaceBottomFrontLeftToTopDeltaX
                  * pyramidFrontLeftEdgeSlope;

      let darkPyramidFaceBottomBackLeftX =
          darkPyramidFaceBottomFrontLeftX
              - darkPyramidFaceBottomFrontLeftToBottomBackLeftDeltaX;
      let darkPyramidFaceBottomBackLeftY =
          darkPyramidFaceBottomFrontLeftY
              - darkPyramidFaceBottomFrontLeftToBottomBackLeftDeltaY;

      let darkPlatformFaceTopFrontLeftX =
          darkPyramidFaceBottomFrontLeftX
              + darkPyramidFaceToDarkPlatformFaceDeltaY
                    / pyramidFrontLeftEdgeSlope;
      let darkPlatformFaceTopFrontLeftY =
          darkPyramidFaceBottomFrontLeftY
              + darkPyramidFaceToDarkPlatformFaceDeltaY;

      let [darkPlatformFaceBottomFrontLeftX, darkPlatformFaceBottomFrontLeftY] =
          computeLineAndCircleIntersections(
              darkPlatformFaceTopFrontLeftX,
              darkPlatformFaceTopFrontLeftY,
              pyramidFrontLeftEdgeSlope,
              /* cx= */ logoCenterX,
              /* cy= */ logoCenterY,
              outerCircleRadius - 1)[1];

      let brightPlatformFaceFrontRightX =
          darkPlatformFaceBottomFrontLeftX
              + brightPlatformFaceBottomLeftToRightDeltaX;
      let brightPlatformFaceFrontRightY =
          Math.sqrt(
              Math.pow(outerCircleRadius - 1, 2)
                  - Math.pow(
                      brightPlatformFaceFrontRightX - logoCenterX, 2))
          + logoCenterY;

      pyramidBackLeftEdgeSlope =
          (darkPyramidFaceTopY - darkPyramidFaceBottomBackLeftY)
              / (darkPyramidFaceTopX - darkPyramidFaceBottomBackLeftX);

      let [darkPlatformFaceTopBackLeftX, darkPlatformFaceTopBackLeftY] =
          computeLinesIntersection(
              darkPlatformFaceTopFrontLeftX,
              darkPlatformFaceTopFrontLeftY,
              darkPyramidFaceBottomFrontLeftToBottomBackLeftDeltaY
                  / darkPyramidFaceBottomFrontLeftToBottomBackLeftDeltaX,
              darkPyramidFaceTopX,
              darkPyramidFaceTopY,
              pyramidBackLeftEdgeSlope);

      let [darkPlatformFaceBottomBackLeftX, darkPlatformFaceBottomBackLeftY] =
          computeLineAndCircleIntersections(
              darkPlatformFaceTopBackLeftX,
              darkPlatformFaceTopBackLeftY,
              pyramidBackLeftEdgeSlope,
              /* cx= */ logoCenterX,
              /* cy= */ logoCenterY,
              outerCircleRadius - 1)[1];

      let darkPlatformFaceTopBackRightX = darkPlatformFaceTopBackLeftX + 23.5;
      let darkPlatformFaceTopBackRightY = darkPlatformFaceTopBackLeftY;

      let darkPlatformFaceTopFrontRightX = darkPlatformFaceTopBackRightX + 6;
      let darkPlatformFaceTopFrontRightY =
          darkPlatformFaceTopBackRightY
              + darkPyramidFaceBottomFrontLeftToBottomBackLeftDeltaY;

      let darkPlatformPath =
          document.createElementNS("http://www.w3.org/2000/svg", 'path');
      darkPlatformPath.setAttribute(
        'd',
        `M ${darkPlatformFaceBottomBackLeftX * percentToPixelsFactor}
           ${darkPlatformFaceBottomBackLeftY * percentToPixelsFactor}
         L ${darkPlatformFaceTopBackLeftX * percentToPixelsFactor}
           ${darkPlatformFaceTopBackLeftY * percentToPixelsFactor}
         L ${darkPlatformFaceTopBackRightX * percentToPixelsFactor}
           ${darkPlatformFaceTopBackRightY * percentToPixelsFactor}
         L ${darkPlatformFaceTopFrontRightX * percentToPixelsFactor}
           ${darkPlatformFaceTopFrontRightY * percentToPixelsFactor}
         L ${brightPlatformFaceFrontRightX * percentToPixelsFactor}
           ${brightPlatformFaceFrontRightY * percentToPixelsFactor}
         A ${(outerCircleRadius - 1) * percentToPixelsFactor}
           ${(outerCircleRadius - 1) * percentToPixelsFactor} 0 0 1
           ${darkPlatformFaceBottomBackLeftX * percentToPixelsFactor}
           ${darkPlatformFaceBottomBackLeftY * percentToPixelsFactor}`);
      darkPlatformPath.setAttribute('stroke', 'black');
      //darkPlatformPath.setAttribute('stroke-linejoin', 'round');
      darkPlatformPath.setAttribute('fill', 'black');
      drawingMask.append(darkPlatformPath);

      let darkPyramidFace =
          document.createElementNS("http://www.w3.org/2000/svg", 'polygon');
      darkPyramidFace.setAttribute(
          'points',
          `${darkPyramidFaceTopX * percentToPixelsFactor}
           ${darkPyramidFaceTopY * percentToPixelsFactor}
           ${darkPyramidFaceBottomFrontLeftX * percentToPixelsFactor}
           ${darkPyramidFaceBottomFrontLeftY * percentToPixelsFactor}
           ${darkPyramidFaceBottomBackLeftX * percentToPixelsFactor}
           ${darkPyramidFaceBottomBackLeftY * percentToPixelsFactor}`);
      darkPyramidFace.setAttribute('stroke', 'black');
      darkPyramidFace.setAttribute('fill', 'black');
      drawingMask.append(darkPyramidFace);

      let pyramidFrontRightEdgeSlope =
          (brightPlatformFaceFrontRightY - darkPyramidFaceTopY)
              / (brightPlatformFaceFrontRightX - darkPyramidFaceTopX);

      let [brightPyramidFaceBottomFrontRightX,
           brightPyramidFaceBottomFrontRightY] =
               computeLinesIntersection(
                   darkPyramidFaceTopX,
                   darkPyramidFaceTopY,
                   pyramidFrontRightEdgeSlope,
                   darkPyramidFaceBottomFrontLeftX,
                   darkPyramidFaceBottomFrontLeftY,
                   /* slope2= */ 0);

      let brightPyramidFace =
          document.createElementNS("http://www.w3.org/2000/svg", 'polygon');
      brightPyramidFace.setAttribute(
          'points',
          `${darkPyramidFaceTopX * percentToPixelsFactor}
           ${darkPyramidFaceTopY * percentToPixelsFactor}
           ${darkPyramidFaceBottomFrontLeftX * percentToPixelsFactor}
           ${darkPyramidFaceBottomFrontLeftY * percentToPixelsFactor}
           ${brightPyramidFaceBottomFrontRightX * percentToPixelsFactor}
           ${brightPyramidFaceBottomFrontRightY * percentToPixelsFactor}`);
      brightPyramidFace.setAttribute('stroke', 'white');
      brightPyramidFace.setAttribute('fill', 'white');
      drawingMask.append(brightPyramidFace);

      let brightPlatformFaceTopFrontLeftX =
          darkPlatformFaceTopBackLeftX + darkPlatformFaceTopFrontRightX
              - darkPlatformFaceTopBackRightX;
      let brightPlatformFaceTopFrontLeftY = darkPlatformFaceTopFrontRightY;

      let brightPlatformPath =
          document.createElementNS("http://www.w3.org/2000/svg", 'path');
      brightPlatformPath.setAttribute(
        'd',
        `M ${darkPlatformFaceBottomFrontLeftX * percentToPixelsFactor}
           ${darkPlatformFaceBottomFrontLeftY * percentToPixelsFactor}
         L ${brightPlatformFaceTopFrontLeftX * percentToPixelsFactor}
           ${brightPlatformFaceTopFrontLeftY * percentToPixelsFactor}
         L ${darkPlatformFaceTopFrontRightX * percentToPixelsFactor}
           ${darkPlatformFaceTopFrontRightY * percentToPixelsFactor}
         L ${brightPlatformFaceFrontRightX * percentToPixelsFactor}
           ${brightPlatformFaceFrontRightY * percentToPixelsFactor}
         A ${(outerCircleRadius - 1) * percentToPixelsFactor}
           ${(outerCircleRadius - 1) * percentToPixelsFactor} 0 0 1
           ${darkPlatformFaceBottomFrontLeftX * percentToPixelsFactor}
           ${darkPlatformFaceBottomFrontLeftY * percentToPixelsFactor}`);
      brightPlatformPath.setAttribute('stroke', 'white');
      //darkPlatformPath.setAttribute('stroke-linejoin', 'round');
      brightPlatformPath.setAttribute('fill', 'white');
      drawingMask.append(brightPlatformPath);

      function computeLinesIntersection(x1, y1, slope1, x2, y2, slope2) {
        return [
            (slope1 * x1 - y1 - slope2 * x2 + y2) / (slope1 - slope2),
            (slope1 * (slope2 * x1 + y2) - slope2 * (slope1 * x2 + y1))
                / (slope1 - slope2)];
      }

      function computeLineAndCircleIntersections(
          lx, ly, slope, cx, cy, radius) {
        let a = 1 + Math.pow(slope, 2),
            b = 2 * (slope * ly - cx - Math.pow(slope, 2) * lx - slope * cy),
            c = Math.pow(cx, 2)
                + Math.pow(slope * lx - ly + cy, 2)
                - Math.pow(radius, 2);
        let x1 = (-b + Math.sqrt(Math.pow(b, 2) - 4 * a * c)) / (2 * a);
        let x2 = (-b - Math.sqrt(Math.pow(b, 2) - 4 * a * c)) / (2 * a);
        let y1 = slope * (x1 - lx) + ly;
        let y2 = slope * (x2 - lx) + ly;
        return [[x1, y1], [x2, y2]];
      }

      function drawCircle(cx, cy, radius, stroke, strokeWidth, fill) {
        let circle =
            document.createElementNS("http://www.w3.org/2000/svg", 'circle');
        circle.setAttribute('cx', `${cx}%`);
        circle.setAttribute('cy', `${cy}%`);
        circle.setAttribute('r', `${radius}%`);
        circle.setAttribute('stroke', stroke);
        circle.setAttribute('stroke-width', strokeWidth);
        circle.setAttribute('fill', fill);
        drawingMask.append(circle);
      }
    </script>
  </div>
</body>
